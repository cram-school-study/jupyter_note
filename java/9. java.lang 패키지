1.1 Object 클래스의 메서드
- 모든 클래스의 최고 조상, 오직 11개의 메서드만을 가지고 있다.
- notify(), wait() 등은 쓰레드와 관련된 메서드이다.
- equals(), hashCode(), toString()은 적절히 오버라이딩해야 한다.
- Object 클래스의 equals, hashcode 두개의 메서드는 각각 오버라이딩해서 써야한다
 -> String 클래스의 equals 메서드는 오버라이딩으로 내부의 값을 비교하여 true/false를 반환하도록 만든것
 -> 만약 Object클래스에서 상속받은 개인이 만든 클래스의 경우는 내용물을 비교하지못함.
 -> 즉, a = new a1(), b = new b1(), a.eqals(b) => 결과값 false가 나온다.

* == - 주소값 비교, .equals - 내부 안의 값 비교
* == - 주소값을 비교하기때문에, 다른 객체의 int에 같은 숫자여도 false
* 업캐스팅 후 다운캐스팅을 한다고해도 값이 날아가는것은 없다. 이유 - 주소값을 참고하는것이기때문!!

1.2 equals()
- 객체 자신과 주어진 객체(obj)를 비교한다. 같으면 true, 다르면 false.
- Object에 정의된 equals()는 참조변수 값(객체의 주소)을 비교한다.
- equals()를 오버라이딩해서 인스턴스변수의 값을 비교하도록 바꾼다.
- 임의적으로 만든 그 외의 class들은 오버라이딩해서 지정해야한다.
* String클래스만 예외적으로 오버라이딩이 되어있다. 
 -> 이유는? 예상으로는 문자열만 리터럴과 new형식이 공존해서 그런 것 같다.

1.3 hashCode()
- 객체의 해시코드(int)를 반환하는 메서드(해시함수), 다량의 데이터를 저장&검색하는 해싱기법에 사용
- Object 클래스의 hashCode()는 객체의 내부주소를 반환한다.
- equals()를 오버라이딩하면, hashCode()도 같이 오버라이딩 해야 한다.
  equals()의 결과가 true인 두 객체의 hash code는 같아야하기 떄문
- System.indentityHashCode(Object obj)는 Object클래스의 hashCode()와 동일한 결과를 반환한다.
- hasCode() 함수를 오버라이딩 할시에 Object.hash(변수1,변수2,...)의 방식으로 사용하면 됨.

* hascode를 쓰는이유 - hashTable, hashMap등의 값을 저장할때 int값이 hash로 값을 찾으면 매우 빠르게 찾을수 있기때문에 hashcode사용
                    - 컬렉션프레임워크에 비해 속도가 빠르다는 장점이 있을건데 요것도 갯수 정해져있지 않은 장점을 따라가는지?
                     ->  잘못된 생각 컬렉션프레임워크에 hashMap이 들어감 즉, hashMap도 갯수가 정해져있지않다.
                    - hashMap에서 Key로는 String이 주로 쓰이는데 해당 키값으로는 hashCode만 비교하지않고, equals()==true인지도 같이 비교한다.
* 컬렉션프레임워크 - list,set,map컬렉션들 ex) arraylist
                   - 갯수가 정해져있지않은 것들은 저장할때 유용함
* 현재 알고있는 hashCode(), equals() 메서드의 경우는 논리적 동등 비교를 하기위해서 만들어진 오버라이딩 방식, 다른방식이 있는지는 모르겠음.

1.4 toString()
- 객체의 정보를 문자열로 제공할 목적으로 정의된 메서드

1.5 getClass()
- 자신이 속한 클래스의 Class객체를 반환하는 메서드
- Class객체는 클래스의 모든 정보를 담고 있으며, 클래스당 단 1개만 존재하고, 클래스파일이 메모리에 로드될때 생성된다.


2.1 
String 클래스의 특징
- 문자열 배열(char[])과 그에 관련된 메서드들이 정의되어 있다.
- String 인스턴스의 내용은 바꿀 수 없다.(immutable)

2.2 
빈 문자열
- 내용이 없는 문자열, 크기가 0인 char형 배열을 저장하는 문자열
- 크기가 0인 배열을 생성하는 것은 어느 타입이나 가능
- String str = ""; 은 가능해도 char c = '';는 불가능
- String은 참조형의 기본값인 null보다 빈 문자열로 초기화하고
- char형은 기본값인 '\u0000'보다 공백으로 초기화하자.

2.3
String클래스의 생성자와 메서드
- 여러가지가 있는데 이건 보고 외워둘것


* String 클래스의 메서드 
  int compareTo - -1 : 오른쪽 값이 더 크다. 양수 : 왼쪽이 더 크다 0 : 같다.
  - 정렬(sort)할때 많이 쓰인다.


3.1
StringBuffer 클래스의 특징
- String처럼 문자형 배열(char[])을 내부적으로 가지고 있다.
- 그러나, String클래스와 달리 내용을 변경할 수 있다.(mutable)
- 인스턴스를 생성할 때 버퍼(배열)의 크기를 충분히 지정해주는 것이 좋다.
 (버퍼가 작으면 성능 저하 - 작업 중에 더 큰 배열이 추가로 생성됨)
- String클래스와 달리 equals()를 오버라이딩하지 않았다는 점에 주의!!!

3.2 StringBuffer클래스의 생성자와 메서드

4.1 Math 클래스


4.2 wrapper 클래스
- 기본형을 클래스로 정의한 것. 기본형 값도 객체로 다뤄져야할 때가 있다.
- 내부적으로 기본형 변수를 가지고 있다.
- 값을 비교하도록 equals()가 오버라이딩되어 있다.

4.3 Number클래스
- 숫자를 멤버변수로 갖는 클래스의 조상(추상클래스)



























