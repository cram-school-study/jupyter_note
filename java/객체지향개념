1. 객체지향의 개념
OOP - Object Oriented Programing

1-1.역사

1-2. 특징

1) ver 1
1. 기존의 프로그래밍 언어와 크게 다르지 않다.
2. 코드의 재사용성이 높다.
3. 코드의 관리자 쉬워졌다.
4. 신뢰성이 높은 프로그램의 개발을 가능하게 한다.

2) ver 2
1. 추상화 - 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념
          - 객체들의 공통된 특징을 파악해 정의해놓은 설계기법
2. 캡슐화 - 불필요한 정보를 감출 수 있다. - 정보은닉이 가능하다.
            ( 캡슐화가 정보은닉이 가능하다는거지 동일한 개념은 아님{ 캡슐화 != 정보은닉 } )
          - 접근제어자 (public, protected, private)
3. 상속 - 코드의 중복을 없앨 수 있다.
        - 부모 - 자식 관계로 상속을 하여 코드의 중복 문제를 일부 해결할 수 있다.
4. 다형성 - 형태가 같은데 다른 기능을 하는 것.
          - 오버라이딩은 이와 관련된 기능임



2. 클래스와 객체
- 객체가 더 큰 범위, 객체 안에 인스턴스가 포함됨
- 인스턴스화(instntiate) - 클래스->인스턴스(객체)

- 객체는 속성과 기능의 집합이며, 속성과 기능을 객체의 멤버라고 한다.
- 속성은 변수로, 기능은 메서드로 정의한다.

* toggle - boolean -> 2개가 변환하는 것(내가 평소에 flag로 지정하는 것)
* File기능은 OS에다가 권한을 넘기는것!?!

* iv = Instance value
* cv = class value, static value라고도 한다.
* lv = local value

3. 변수와 메서드

3-1.
클래스변수 - 각 인스턴스의 개별적인 독립공간, 인스턴스별 다른 값 저장 가능
인스턴스변수 - 같은 클래스의 모든 인스턴스들이 공유하는 변수
지역변수 - 메서드 내에서 선언되며, 메서드의 종료와 함께 소멸
-> 요즘은 변수보다 필드라고 명명하는듯??

3-2.
메서드 - 클래스 내부에서 쓰여진 함수
함수 - 클래스 외부에서 쓰여진 함수


3-3.
오버로딩 - 이름이 동일한 메서드를 여러개 정의하는 것.
         - 매개변수 명이 다른것은 오버로딩이 아님.
 
조건
1. 메서드 이름 같음
2. 매개변수의 개수 또는 타입이 달라야한다.
3. 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않는다.
 (리턴 타입은 오버로딩을 구현하는데 아무런 영향을 주지 않는다.)

* 애매한 경우 int,long으로 되어있을경우 int,int로 호출할경우 확인해보자 -> 자동 형변환 가능시에는 된다.
method2(int,int)
method2(int,long){}

오버라이딩 - 상속받은 동일한 명의 메서드를 자식 클래스에서 재정의 하는 것.

3-4.
return  - 현재 호출된 메서드를 종료하고, 호출한 메서드로 돌아간다.
* return문의 개수 자체를 최소화 하는것이 좋음

3-5.
JVM의 메모리 구조

메서드영역 - 클래스 정보, 클래스 변수가 저장되는 곳
호출 스택 -  메서드의 작업공간, 메서드가 호출되면 수행에 필요한 메모리공간 할당 후 종료되면 메모리 반환됨
힙 - 인스턴스가 생성되는 공간. new연산자로 인한 객체,배열 등은 여기에 생성된다.
   - 가비지컬렉터가 지우는 공간
   
* runtime에 사용되는 스택 구조 -> Last in First out

3-6.
기본형 매개변수와 참조형 매개변수

기본형 매개변수 - read only
참조형 매개변수 - read & write


3-7. 
재귀호출( recursive call )
- 자기자신을 반복적으로 호출하는 것
ex) Quick Sort, 팩토리얼, 제곱, 트리운행, 폴더목록 표시, ...


3-8.
클래스 메서드와 인스턴스 메서드

인스턴스 메서드 - 인스턴스 생성 후 사용 가능한 메서드
                - 메서드 내에서 인스턴스 변수,클래스 변수 사용 가능

클래스 메서드 - static 메서드
              - 객체 생성없이 바로 호출 가능
              - 메서드 내에서 인스턴스변수 사용 불가
              - 메서드 내부에서 만약 인스턴스 변수를 사용하지 않으면 해당 클래스 메서드로 변경할것을 고려.
              
4. 생성자

4-1.
생성자 - 인스턴스가 생성될때마다 호출되는 '인스턴스 초기화 메서드'
       - 모든 클래스에는 반드시 하나 이상의 생성자가 있어야한다.(이상!! 이상!!! 무조건 1개 x!!)
       - 클래스의 이름과 같아야한다.
       - 생성자는 리턴값이 없으나, void를 쓰지도 않는다.
       - constructor

기본 생성자 - 매개변수가 없는 생성자
            - 클래스에 생성자가 하나도 없으면 컴파일러가 기본 생성자를 추가한다.
            - 하나라도 생성자가 있으면 컴파일러는 기본 생성자를 추가하지않는다.
            
4-2.
this() - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용
       - 다른 생성자 호출은 생성자의 첫 문장에서만 가능!!!! - *첫줄에만 사용가능!!!
       - 생성자 안에서 변수의 명이 같은것을 구분하기위해 나옴, 변수명이 다를경우 굳이 쓸 필요없음
       
this - 인스턴스 자신을 가리키는 참조변수.
     - 인스턴스의 주소가 저장되어있음.
     - 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재.
     
5-1.
변수의 초기화 - 변수를 선언하고 처음으로 값을 저장하는 것
              - 멤버변수(인스턴스변수, 클래스변수)와 배열은 각 타입의 기본값으로 자동 초기화되므로 초기화를 생략할 수 있다.
              - 지역변수는 사용전에 반드시 초기화를 해주어야한다.
              - ,를 사용하여 1줄에 초기화를 할때 타입이 다른것은 할 수 없다.
              
* 초기화 순서 - 클래스 초기화 -> 인스턴스 초기화
              - 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자
           
5-2.
초기화 블럭

클래스 초기화 블럭 - static {} - 클래스가 생성될시에 초기에 자동으로 실행
인스턴스 초기화 블럭 - {} - 인스턴스가 생성될시에 초기에 자동으로 실행
   
   
   
6. 상속

6-1.상속 - 기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것.
         - 두 클래스를 조상과 자손으로 관계를 맺어주는 것.
         - 자손은 조상의 모든 멤버를 상속 받는다.(생성자, 초기화블럭 제외, 멤버 = 변수 + metohd)
         - 자손의 멤버개수는 조상보다 적을 수 없다.(같거나 많다.)

6-2 포함 - 한 클래스의 멤버변수로 다른 클래스를 선언하는 것.
         - 작은 단위의 클래스를 먼저 만들고, 이들을 좋바해서 하나의 커다란 클래스를 만든다.
         
6-3
클래스간의 관계 결정하기 - 상속 vs 포함

is - a - 상속관계 - ex) 원은 점이다.
has - a - 포함관계 - ex) 원은 점을 가지고있다.
-> 원과 점의 클래스관계는 has-a로 포함관계로 관계를 설정해야한다.


* 기본 생성자는 항상 생성해주도록 한다.
-> 부모클래스의 기본생성자가 지정되어있지 않고, 임의적인 생성자가 하나 지정되어있을 경우,
   자식 클래스에서 this.부모의 변수를 사용시에 오류 발생.
* 생성자의 첫줄은 항상 다른 생성자를 호출해야한다. - (미지정시 super() 생략)
 

6-4.
super - 부모 클래스의 생성자를 실행하는 것.
      - 항상 모든 생성자는 super()가 생략되어있음.
      - 모든 클래스는 최상위 클래스 Object() 클래스로부터 상속받아져 있다.(생략)

*Object 클래스는 11개의 메서드를 가지고있다.

6-5.
단일상속 - Java는 단일상속만을 허용한다.(C++은 다중상속 허용)


7-1.
오버라이딩 - over ridding 또는 over writing
           - 조상클래스로부터 상속받은 메서드의 내용을 상속받은 클래스에 맞게 변경하는 것.

* 인스턴스.toString() - 클래스명@주소값
* syso(인스턴스) - 클래스명@주소값

7-2.
오버라이딩의 조건
1. 선언부가 같아야 한다. (이름, 매개변수, 리턴타입)
2. 접근제어자를 좁은 범위로 변경할 수 없다.
 - 조상의 메서드가 protected라면, 범위가 같거나 넓은 protected나 pulibc으로만 변경할 수 있다.
3. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

* 오버로딩과 오버라이딩의 차이점
 - 오버로딩은 상속을 받지 않고 사용이 가능하지만, 오버라이딩은 상속을 받은것을 재정의 하는것.
   즉, 차이점은 상속을 받느냐 받지않느냐!!
   
7-3.
this() - 생성자, 자기자신
super() - 생성자, 조상의

this - 참조변수 - 자기자신의 인스턴스 변수, 로컬변수를 구분하기 위해
super - 참조변수 - 조상의 인스턴스 변수, 클래스 변수를 참조하기 위해

* 상속시에 부모 클래스, 자식 클래스에 동일한 필드가 있을경우에는 부모 클래스의 필드가 숨겨진다.

!!!!!
1. 부모 자식 같은 명의 변수를 가진 후 오버라이딩을 하지않고 자식 클래스에서 부모의 메서드를 실행
2. 부모에 this(2,2)로 생성자가 존재하고, 자식은 기본 생성자로 하였을 때, 


8-1. 
제어자 
- 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여한다.
- 접근제어자 - public, protected, default(생략 가능), private
- 그 외 - static, final, abstract, native, tansient, synchronized, volatile, strictfp

8-2 
static 
- 클래스의, 공통적인
- static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

8-3
- 마지막의, 변경될 수 없는
- final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수
- final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
- 변경 될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 불가능
- 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

8-4.
접근 제어자 - pdpp 외울것 - 제한된 것 -> 풀리는 것순
private - 같은 클래스 내에서만 접근 가능.
default - 같은 패키지 내에서만 접근 가능.
protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능.
public - 접근 제한이 전혀 없다.

* 패키지 - OS(파일)입장에서 보면 디렉토리

8-5.
abstract
- 추상의, 미완성의
- 몸통이 없는 메서드
- abstract - 클래스, 메서드
- abstract 메서드가 하나라도 있다면 class는 abstract가 붙어야한다.

8-6.
접근 제어자를 이용한 캡슐화
- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

8-7.
제어자의 조합

클래스 - public, default, final, abstract
메서드 - 모든 접근 제어자, final, abstract, static
멤버변수 - 모든 접근 제어자, final, static
지역변수 - final

1. 메서드에 static과 abstract를 함께 사용할 수 없다.
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
- abstract는 상속을 통해 써먹는다.
3. abstract메서드의 접근제어자가 private일 수 없다.
4. 메서드에 private과 final을 같이 사용할 필요는 없다.


9-1.
다형성(polymorphism)
- 여러가지 형태를 가질 수 있는 능력
- 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것 즉, 조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는것이 다형성.
-> 형변환은 가능하지만, 자손의 기능의 전부를 사용할 수 없다.
- 자손 -> 조상 형변환 생략이 가능하지만, 조상 -> 자손은 형변환 생략이 불가능하다.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* 조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는것이 다형성.!!!!!!!!!!!
* 반대로 자손타입의 참조변수로 조상타입의 객체를 다룰 수 없다!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


* 형변환을 하는 이유 - 메소드를 늘리고 줄이려고~

9-2.
instance of 
- 참조하는 인스턴스의 실제 타입을 체크하는데 사용
- 연산결과가 true이면, 해당 타입으로 형변환 가능

9-3.
****
참조변수와 인스턴스변수의 연결
- 멤버변수가 중복정의된 경우, 참조변수의 타입에 따라 연결되는 멤버변수가 달라진다.
(참조변수타입에 영향받음)
- 메서드가 중복정의된 경우, 참조변수의 타입에 관계없이 항상 실제 인스턴스의 타입에 정의된 메서드가 호출된다.
(참조변수타입에 영향받지않음.)

* 왼쪽이 부모인것 - new연산자로 생성할경우
                  - 형변환시 생략할 경우
  
  오른쪽이 부모인것 - instance of시에 true를 표출할 경우


10.1
추상클래스
- 클래스가 설계도라면 추상클래스는 미완성 설계도
- 추상메서드르 포함하고 있는 클래스 - 1개라도 추상메서드면 추상 클래스임
- 일반 메서드가 추상메서드를 호출할 수 있다.
- 완성된 설계도가 아니므로 인스턴스를 생성할 수 없다.
- 다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다.
- 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용

10.2
추상클래스의 작성
- 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나, 기존클래스의 공통 부분을 뽑아서 추상클래스를 만든다.


10.3 
인터페이스(interface)
- 일종의 추상클래스. 추상클래스(미완성 설계도)보다 추상화 정도가 높다.
- 추상메서드와 상수만을 멤버로 가질 수 있다.
- 인스턴스를 생성할 수 없고, 클래스 작성에 도움을 줄 목적으로 사용된다.
- 미리 정해진 규칙에 맞게 구현하도록 표준을 제시하는데 사용된다.


10.4
인터페이스의 작성
- class 대신 interface를 사용한다는 것 외에는 클래스 작성과 동일하다.
- 하지만 구성요소(멤버)는 추상메서드와 상수만 가능하다.
- *모든 멤버변수는 public static final 이어야하며, 이를 생략할 수 있다.
- *모든 메서드는 public abstract 이어야하며, 이를 생략할 수 있다.

* 인터페이스가 상속되었을때, public abstract가 생략되어있기때문에 상속받은 메서드에도 public 써주어야함 
- 오버라이딩이기때문에 생략이 가능하기때문에 자주 모름 또는 인터페이스에 생략하지말고 적어주면 된다. -> 다시 한번 읽어볼것 뭔말이여???

* 접근제어자의 범위는 좁아져서는 안된다.

* 인터페이스와 추상화 클래스의 차이점
- 인터페이스는 모든 멤버가 추상화(abstract)이고, 추상화 클래스는 1개만 추상화(abstract)이어도 추상화 클래스이다.

10.5
인터페이스의 상속
- 인터페이스도 클래스처럼 상속이 가능하다.(클래스와 달리 다중상속 허용)
(추상화 클래스는 구현이 되지않은 것도 포함하고있지만, 인터페이스는 전부 다 구현되지않은경우이므로 다중상속이 되어도 괜찮다. - 인터페이스를 클래스처럼 다중상속을 막을 이유가 없음.)
- 인터페이스는 Object 클래스와 같은 최고 조상이 없다.

10.6
인터페이스의 구현
- 인터페이스를 구현하는것은 클래스를 상속받는 것과 같다. 다만 extends 대신 implements를 사용한다.
- 인터페이스에 정의된 추상메서드를 완성해야한다.
- 상속과 구현이 동시에 가능하다.


******************************************************************************************
* import문의 선언 
* import문은 컴파일 시에 처리되므로 프로그램의 성능에 아무런 영향을 끼치지않는다.
* 이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.
******************************************************************************************

* 인터페이스는 추상메서드의 집합이다.
* 인터페이스는 iv, cv를 가질 수 없다. only 상수만
* class 같은 문법으로 사용된다. - 다만 명령어는 implements interface interface명
* interface끼리 상속받을시에는 extends를 사용한다.
* interface는 Object클래스와 같은 최고 조상이 없다.
* implements를 하는것은 상속x 구현한다고 한다. -> 임의로 이렇게 설명하시는 듯?

10.7
인터페이스를 이용한 다형성
- 인터페이스 타입의 변수를 인터페이스를 구현한 클래스의 인스턴스를 참조할 수 있다.
- 인터페이스를 메서드의 매개변수 타입으로 지정할 수 있다.
- 인터페이스를 메서드의 리턴타입으로 지정할 수 있다.


10.8
인터페이스의 장점
- 개발 시간 단축
-> 인터페이스 선언부만 알면 구현하는 쪽에서는 선언부만 가지고 양쪽에서 동시 개발이 가능하기 때문.
-> 단축에 큰 의미가 있는건지? 선언만 구현하는거면 메서드명만 정의하는건디....????

- 표준화 가능
-> 기본틀을 인터페이스로 작성하면 일관되고 정형화된 프로그램의 개발이 가능.

- 서로 관계없는 클래스에게 관계를 맺어줌
-> 서로 상속이 아니어도, 같은 조상 클래스를 가지고 있지 않은 서로 관계가 없는 클래스 들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계 맺기 가능.
-> ex) scv 지상군 수리 기능 - 드랍쉽 공중 유닛 - 치료 가능
                            - 마린 지상군 유닛 - 치료 불가능
                            - 탱크 지상군 유닛 - 치료 가능
  -> 치료 기능이라는 인터페이스를 만들어서 지상,공중으로 구분된 클래스 구분에서 별도의 공통기능으로 묶어서 관계를 맺게 해주기가 가능.

- 독립적인 프로그래밍이 가능
-> 인터페이스를 사용하면 클래스 선언, 구현 분리 가능하기때문 독립적으로 프로그램 작성이 가능
-> 클래스간의 관계를 직접이 아닌 간접적인 인터페이스 방식으로 변경하면 다른 클래스에 영향을 미치지않는 독립적인 프로그래밍이 가능하다.


8.1
내부클래스
- 클래스 안에 선언된 클래스
- GUI 어플리케이션(AWT, Swing)의 이벤트처리에 많이 사용된다.

내부클래스의 장점
- 내부클래스에서 외부 클래스의 멤버들을 쉽게 접근 가능
- 코드 복잡성 줄임(캡슐화)

8.2
내부 클래스의 종류와 특징
- 내부 클래스의 종류는 변수의 선언위치에 따른 종류와 동일
- 종류 - 인스턴스, 스테틱, 지역, 익명 클래스

8.3
제어자(modifiy)와 접근성
- 내부 클래스의 접근제어자는 변수에 사용할 수 있는 접근제어자와 동일하다.
- static 클래스만 static 멤버를 정의할 수 있다.
- 내부 클래스도 외부클래스의 멤버로 간주되며, 동일한 접근성을 가진다.
- 외부클래스의 지역변수는 final이 붙은 상수만 변수만 접근 가능하다.
  지역클래스의 인스턴스가 소멸된 지역변수를 참조할 수 있기 때문이다.
  -> 지역클래스는 메서드안의 클래스이기때문에 별도로 생각해야함.
     해당 메서드가 실행되고 끝나면 해당 스택은 사라지지만 그 클래스 구현되고 이후 부분에
     new로 생성하고 해당 변수를 활용할 수 있기때문에, final 변수만 가져올수있다! 이렇게 생각해야할듯
     * 구분점으로 final 변수의경우 지역클래스와 일반클래스의 경우의 차이점 메모해둘것!
     -> final 변수는 힙메모리에 참조변수와 동일하게 저장이 된다.
     -> 차이점이랄것도 없고 만들어지는곳이 클래스냐 메서드냐에 따라서 둘다 힙에 저장되기때문에 구분점이 생기는것이며, 지역클래스로는 static을 쓸수가 없는 것 같다.

* final은 객체별로 다르고 변경할 수 없는 상수 취급이기때문에 힙메모리에 저장
* 실제 class파일 생기는건 inner클래스면 상위클래스&하위클래스.class
* 내부클래스는 메서드별로 숫자가 붙음 1,2,3,4,....

8.4
익명 클래스(anonymous class)
- 이름이 없는 일회용 클래스, 선언과 생성을 동시에. 하나의 객체만 생성가능
- 자바스크립트, mfc 등에서 eventlistener등을 주로 활용했던게 이 익명클래스를 활용했던것으로 보임.







